## 🎞 후기
- 처음으로 실제 코딩테스트를 응시하는 환경으로 조성하여 문제를 풀었다.
- SWEA의 D2~D3 수준의 7문제가 주어졌고 6문제까지는 1시간 30분 이내에 풀 수 있었지만 마지막 [암호문1 문제](./SWEA_1228.py)에서 6문제를 푸는데에 쓴 시간 만큼의 고민을 하였다...! (~~하지만 결국 다 풀고나니 그렇게 오래 고민할게 아니었다...~~)
- 아무런 제약없이 편안한 분위기속에서 문제를 맞추는것만 신경을 썼던 여태까지와는 다르게 체력적으로, 정신적으로도 중간중간 어려움이 있었다. 긴 시간 집중할 수 있어야하고 안되는 부분을 계속 붙잡고 그 안에서 오류를 수정하려고 애쓰는 것도 물론 충분히 있을 수 있는 일이지만, 때론 과감하게 처음부터 짜는게 오히려 더 효율적일 수도 있다는 사실을 깨달을 수 있었다.
- **모든것을 하나의 방법으로만 풀려고하는 사고방식과 풀고 있던 방식만을 고수하려는 고집을 버리자.**
- 구조적으로, 수치적으로 푸는것이 무조건 멋진 알고리즘은 아니다, 이로인해 오히려 더 복잡해질 수 있고 다시 읽기도 힘든 경우가 허다했다.
- `Simple is best` 라는 말이 있던가? 문제를 뜯고 뜯어 **최대한 간단하게 해석하는 힘**을 기르자!
- 그리고 알고리즘을 구상하고 구현하기전 **주어진 문제를 충분히 분석해야함**을 다시금 깨달을 수 있었다.

## 💎 가장 강렬했던 문제
- 누가뭐래도 [암호문1 문제](./SWEA_1228.py)
- 선정 이유 : `너무 어렵게 접근함` `문제를 제대로 읽지 않아 입력값을 계속 잘못받았음`

```python
# 한 시간 넘게 붙잡고 있던 풀이를 지우고 처음부터 풀어서 짠 알고리즘
# 전보다 훨씬 깔끔하고 다시 읽기도 편하다
for j in range(len(command)):
    if command[j] == 'I':
        insert_idx = int(command[j + 1])
        insert_num = int(command[j + 2])
        
        for k in range(insert_num):
            origin.insert(insert_idx + k, command[j + 3 + k])

# 전에 짰던 코드는 날려먹어서 따로 첨부하지는 않지만 위와 같이 idx를 I를 발견할 때 마다
# 상대적인 값으로 접근하지 않고 입력받은 전체 리스트에 대한 idx로 접근하다보니 
# 각 idx간의 관계를 수식으로 찾아내어야 했고 다시 읽었을 때는 복잡해보여서 결국 idx를 구할 때 썼던 종이를 다시 보곤 했다... 
```
